# -*- coding: utf-8 -*-
"""Assignment 3_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13h7PKnXEt-tmVC0cUJMlQ2yq657dLId3
"""

#Question 1

from collections import deque

def find_shortest_path(building, start, target):
    rows, cols = len(building), len(building[0])
    directions = [(0,1), (1,0), (0,-1), (-1,0)]  # Right, Down, Left, Up
    queue = deque([(start[0], start[1], 0, [])])  # (row, col, steps, path)
    visited = set()
    visited.add(start)

    while queue:
        r, c, steps, path = queue.popleft()

        # If we found the target (survivor)
        if (r, c) == target:
            path.append((r, c))  # Add final position to path
            print_grid_with_path(building, path)  # Display the path on the grid
            return f"Shortest path found in {steps} steps! Path: {path}"

        # Explore neighbors
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and building[nr][nc] != 1 and (nr, nc) not in visited:
                queue.append((nr, nc, steps + 1, path + [(r, c)]))  # Append new path
                visited.add((nr, nc))

    return "No path found to survivor!"

def print_grid_with_path(building, path):
    """ Prints the building grid with the shortest path marked as '*' """
    grid_copy = [row[:] for row in building]  # Create a copy to avoid modifying the original grid
    for r, c in path:
        grid_copy[r][c] = '*'

    print("\n Building Map with Shortest Path:")
    for row in grid_copy:
        print(' '.join(str(cell) for cell in row))
    print("\n")

# Example Grid (0 = open path, 1 = obstacle, 'S' = Start, 'T' = Trapped Survivor)
building = [
    [0, 0, 1, 0, 0],
    [1, 0, 1, 0, 1],
    [0, 0, 0, 0, 1],
    [0, 1, 1, 1, 0],
    ['S', 0, 0, 'T', 1]
]

# Finding start (S) and target (T) positions
start, target = None, None
for i in range(len(building)):
    for j in range(len(building[0])):
        if building[i][j] == 'S':
            start = (i, j)
            building[i][j] = 0  # Convert 'S' to open path
        elif building[i][j] == 'T':
            target = (i, j)
            building[i][j] = 0  # Convert 'T' to open path

# Run BFS to find the shortest path and display it
if start and target:
    print(find_shortest_path(building, start, target))
else:
    print("Start or Target not found!")

#Question 2

from collections import defaultdict

class MiningTunnels:
    def __init__(self):
        self.graph = defaultdict(list)
        self.deepest_path = []
        self.max_depth = 0

    def add_tunnel(self, u, v):
        """Adds a bidirectional tunnel between two locations"""
        self.graph[u].append(v)
        self.graph[v].append(u)

    def dfs(self, node, visited, path, depth):
        """Recursive DFS to find the deepest point"""
        visited.add(node)
        path.append(node)

        # Check if we reached a deeper point
        if depth > self.max_depth:
            self.max_depth = depth
            self.deepest_path = list(path)

        # Explore deeper tunnels
        for neighbor in self.graph[node]:
            if neighbor not in visited:
                self.dfs(neighbor, visited, path, depth + 1)

        # Backtrack
        path.pop()
        visited.remove(node)

    def explore_tunnels(self, start):
        """Finds the deepest tunnel path from the starting point"""
        visited = set()
        self.dfs(start, visited, [], 0)
        return self.deepest_path, self.max_depth

# Example Mining Tunnel Network
mining = MiningTunnels()

# Creating tunnels (Graph connections)
mining.add_tunnel(1, 2)
mining.add_tunnel(1, 3)
mining.add_tunnel(2, 4)
mining.add_tunnel(2, 5)
mining.add_tunnel(3, 6)
mining.add_tunnel(5, 7)
mining.add_tunnel(5, 8)
mining.add_tunnel(7, 9)  # Deepest tunnel (Node 9)

# Start exploration from node 1 (Mining entrance)
deepest_path, max_depth = mining.explore_tunnels(1)

print(f"Deepest path: {deepest_path}")
print(f"Maximum depth reached: {max_depth}")

#Question 3

import heapq

class ShippingRoutes:
    def __init__(self):
        self.graph = {}  # Dictionary to store adjacency list

    def add_route(self, city1, city2, distance):
        """Adds a bidirectional route between two cities"""
        if city1 not in self.graph:
            self.graph[city1] = []
        if city2 not in self.graph:
            self.graph[city2] = []

        self.graph[city1].append((distance, city2))
        self.graph[city2].append((distance, city1))  # Since it's bidirectional

    def dijkstra(self, start):
        """Finds the shortest paths from the start city using Dijkstra's Algorithm"""
        min_heap = [(0, start)]  # (distance, city)
        shortest_paths = {city: float('inf') for city in self.graph}
        shortest_paths[start] = 0

        while min_heap:
            current_dist, current_city = heapq.heappop(min_heap)

            for neighbor_dist, neighbor in self.graph[current_city]:
                new_distance = current_dist + neighbor_dist
                if new_distance < shortest_paths[neighbor]:  # Found a shorter path
                    shortest_paths[neighbor] = new_distance
                    heapq.heappush(min_heap, (new_distance, neighbor))

        return shortest_paths

# Example Shipping Routes (Graph Representation)
shipping = ShippingRoutes()

# Adding city routes with fixed distances
shipping.add_route("A", "B", 50)
shipping.add_route("A", "C", 30)
shipping.add_route("B", "D", 70)
shipping.add_route("C", "D", 40)
shipping.add_route("C", "E", 60)
shipping.add_route("D", "F", 20)
shipping.add_route("E", "F", 50)
shipping.add_route("B", "E", 90)

# Compute shortest routes from city A
shortest_routes = shipping.dijkstra("A")

#  Print shortest distance to each city
print(" Shortest Delivery Routes from City A:")
for city, distance in shortest_routes.items():
    print(f" City {city} â†’ {distance} km")

#Question 4

import math

# Tic-Tac-Toe Board Representation
AI = 'X'   # AI plays as 'X'
HUMAN = 'O'  # Opponent plays as 'O'
EMPTY = ' '  # Empty spot

# Function to check if the game is over
def check_winner(board):
    winning_combinations = [(0,1,2), (3,4,5), (6,7,8),  # Rows
                            (0,3,6), (1,4,7), (2,5,8),  # Columns
                            (0,4,8), (2,4,6)]           # Diagonals

    for combo in winning_combinations:
        if board[combo[0]] == board[combo[1]] == board[combo[2]] != EMPTY:
            return board[combo[0]]  # Return 'X' or 'O' as winner

    if EMPTY not in board:
        return "DRAW"  # If no moves left, it's a draw

    return None  # Game not over

# Function to evaluate the board
def evaluate(board):
    winner = check_winner(board)
    if winner == AI:
        return 10
    elif winner == HUMAN:
        return -10
    return 0  # Draw

# Minimax Algorithm Implementation
def minimax(board, depth, is_maximizing):
    score = evaluate(board)

    # Base cases: If game is over, return the score
    if score == 10 or score == -10:
        return score
    if EMPTY not in board:
        return 0  # Draw

    if is_maximizing:
        best = -math.inf
        for i in range(9):
            if board[i] == EMPTY:
                board[i] = AI
                best = max(best, minimax(board, depth + 1, False))
                board[i] = EMPTY  # Undo move
        return best
    else:
        best = math.inf
        for i in range(9):
            if board[i] == EMPTY:
                board[i] = HUMAN
                best = min(best, minimax(board, depth + 1, True))
                board[i] = EMPTY  # Undo move
        return best

# Find the best move for AI
def find_best_move(board):
    best_value = -math.inf
    best_move = -1

    for i in range(9):
        if board[i] == EMPTY:
            board[i] = AI
            move_value = minimax(board, 0, False)
            board[i] = EMPTY  # Undo move

            if move_value > best_value:
                best_value = move_value
                best_move = i

    return best_move

# Example Tic-Tac-Toe board
board = ['', 'O', 'X',
         ' ', 'O', 'O ',
         ' ', ' X', 'X']

best_move = find_best_move(board)
print(f"AI should play at position: {best_move}")